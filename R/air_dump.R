#' Output tables to a specified file format
#'
#' This function uses metadata tables in your base to extract all
#' base table to a different file format. Currently only CSV is supported.
#' For information about creating metadata tables in your base see the
#' \href{https://ecohealthalliance.github.io/eha-ma-handbook/8-airtable.html#managing-data}{EHA MA Handbook}
#'
#' @param base String. ID for your base from Airtable. Generally 'appXXXXXXXXXXXXXX'
#' @param table_name_metadata String. Name of structural metadata table. PROVIDE LINK TO DEF OF STRUCTURAL METADATA
#' @param table_name_description String. Name of the descriptive metadata table. PROVIDE LINK TO DEF OF DESCRIPTIVE METADATA
#' @param output_dir String. Folder containing outputs. If not specified, a folder
#' with the name of the output_id will be used.
#' @param output_format String. Default is csv. Options include: csv
#' @param to_frictionless_data Logical. Requires table_name_metadata and table_name_description.
#' Should data be output as a frictionless data package. (To be Added)
#' @param all_table_names Vector. Do not use if providing table_name_metadata.
#' A character vector of all table names in your base. I.e c("table 1","table 2").
#' @param output_id String. ID used to uniquely identify outputs. A folder with
#' this name will be created in output_dir.
#'
#' @return List of file paths created.
#' @export
#'
#' @examples

air_dump <- function(base = Sys.getenv("airtable_metadata_base"),
                     table_name_metadata = "meta data",
                     table_name_description =  "description",
                     all_table_names = NULL,
                     output_dir = "outputs",
                     output_id = rlang::hash(Sys.time()),
                     output_format = "csv",
                     to_frictionless_data=FALSE){

  if(is.null(output_dir)){
    output_dir <- "."
    message(glue::glue("No ouput_dir provided.
                       Files are being saved directly to ./{output_id}"))
  }

  temp_path <- tempdir()
  ## create dir - should probably go to a temp dir until finished
  output_dir_path <- sprintf("%s/%s",temp_path,output_id)
  dir.create(path = output_dir_path,recursive = T, showWarnings = FALSE)

  ## check that output_format is supported
  output_format <- tolower(output_format)
  output_formats <- c("csv") # potentially include json, txt,xml
  if(!any(output_format %in% output_formats)){
    stop(glue::glue("{output_format} not supported. Use one of {output_formats}"))
  }

  ## load metadata table - limit to just table names
  ### create structural metadata file

  # write structural metadata table
  str_metadata <- airtabler::fetch_all(base,table_name_metadata)
  smf_file_path  <- sprintf("%s/%s.csv",output_dir_path,snakecase::to_snake_case(table_name_metadata))
  # names(str_metadata)  <- snakecase::to_lower_camel_case(names(str_metadata))
  utils::write.csv(str_metadata,smf_file_path,row.names = FALSE)

  base_table_names <- unique(str_metadata$`Table Name`)
  base_table_names_formatted <-  snakecase::to_snake_case(base_table_names)
  purrr::map2(base_table_names,base_table_names_formatted, function(x,y){
    #browser()
    ## get fields from str_metadata

     fields_exp <- str_metadata[str_metadata$`Table Name` == x,"Field Name"]

    ## pull table - add check for blank tables
    x_table <- airtabler::fetch_all(base,x)

    if(!is.data.frame(x_table)){
      x_table <- data.frame(id = character())
    }

    ## add in missing columns
     fields_obs <- names(x_table)
     # drop autogenerated cols from comparison
     fields_obs  <- fields_obs[!grepl(pattern = "^id$|^createdTime$",
                                      x = fields_obs)]
     # check if any discrepancy between metadata and table
     fields_diff <- set_diff(fields_exp,fields_obs)

     if(!is.null(fields_diff)){
      # check for fields in obs not in exp - error
      obs_exp  <- setdiff(fields_obs,fields_exp)
      if(length(obs_exp) != 0){
        stop(glue::glue("Table {x} contains field(s) {obs_exp} not found in {table_name_metadata}. Update metadata table."))
      }
      # check for fields in exp and not in obs - append unless frictionless
      if(!to_frictionless_data){
        exp_obs <- setdiff(fields_exp,fields_obs)
        x_table[exp_obs] <- list(character(0))
      }
     }

     ## clean up field names

    names(x_table)  <- snakecase::to_snake_case(names(x_table))

    # convert list type fields to strings

    x_table_flat <- dplyr::mutate(.data = x_table,
                  dplyr::across(tidyselect:::where(is.list), purrr::flatten_chr))

    ## export to CSV

     output_file_path  <- sprintf("%s/%s.csv",output_dir_path,y)

     utils::write.csv(x_table_flat,output_file_path,row.names = FALSE)
  })

  ## copy files from temp to final

  output_dir_path_final <- sprintf("%s/%s",output_dir,output_id)
  dir.create(output_dir_path_final,recursive = T)

  outputs_list <- list.files(output_dir_path,full.names = T)

  file.copy(from = outputs_list,to = output_dir_path_final,recursive = FALSE ,copy.mode = TRUE)

  message(glue::glue("Files can be found here: {output_dir_path_final}"))

  return(list.files(output_dir_path_final,full.names = T))

}

#' Get items that differ between x and y
#'
#' Unlike setdiff, this function creates the union of x and y then
#' removes values that are in the intersect, providing values
#' that are unique to X and values that are unique to Y.
#'
#' @param x a set of values.
#' @param y a set of values.
#'
#' @return Unique values from X and Y, NULL if no unique values.
#' @export
#'
#' @examples
#' a <- 1:3
#' b <- 2:4
#'
#' set_diff(a,b)
#' # returns 1,4
#'
#' x <- 1:3
#' y <- 1:3
#'
#' set_diff(x,y)
#' # returns NULL
#'
set_diff <- function(x,y){
  u <- union(x,y)
  i <- intersect(x,y)
  j <- (u %in% i)

  if(all(j)){
    return(NULL)
  }

  diff <- u[!(j)]
  return(diff)
}

