#' Output tables to a specified file format
#'
#' This function uses metadata tables in your base to extract all
#' base table to a different file format. Currently only CSV is supported.
#' For information about creating metadata tables in your base see the
#' \href{https://ecohealthalliance.github.io/eha-ma-handbook/8-airtable.html#managing-data}{EHA MA Handbook}
#'
#' @param base String. ID for your base from Airtable. Generally 'appXXXXXXXXXXXXXX'
#' @param table_name_metadata String. Name of structural metadata table. PROVIDE LINK TO DEF OF STRUCTURAL METADATA
#' @param table_name_description String. Name of the descriptive metadata table. PROVIDE LINK TO DEF OF DESCRIPTIVE METADATA
#' @param output_dir String. Folder containing outputs. If not specified, a folder
#' with the name of the output_id will be used.
#' @param output_format String. Default is csv. Options include: csv
#' @param to_frictionless_data Logical. Requires table_name_metadata and table_name_description.
#' Should data be output as a frictionless data package. (To be Added)
#' @param all_table_names Vector. Do not use if providing table_name_metadata.
#' A character vector of all table names in your base. I.e c("table 1","table 2").
#' @param output_id String. ID used to uniquely identify outputs. A folder with
#' this name will be created in output_dir.
#'
#' @return List of file paths created.
#' @export
#'
#' @examples

# air_dump <- function(base = Sys.getenv("airtable_metadata_base"),
#                      table_name_metadata = "meta data",
#                      table_name_description =  "description",
#                      all_table_names = NULL,
#                      output_dir = "outputs",
#                      output_id = rlang::hash(Sys.time()),
#                      output_format = "csv",
#                      to_frictionless_data=FALSE){
#
#   if(is.null(output_dir)){
#     output_dir <- "."
#     message(glue::glue("No ouput_dir provided.
#                        Files are being saved directly to ./{output_id}"))
#   }
#
#   temp_path <- tempdir()
#   ## create dir - should probably go to a temp dir until finished
#   output_dir_path <- sprintf("%s/%s",temp_path,output_id)
#   dir.create(path = output_dir_path,recursive = T, showWarnings = FALSE)
#
#   ## check that output_format is supported
#   output_format <- tolower(output_format)
#   output_formats <- c("csv") # potentially include json, txt,xml
#   if(!any(output_format %in% output_formats)){
#     stop(glue::glue("{output_format} not supported. Use one of {output_formats}"))
#   }
#
#   ## load metadata table - limit to just table names
#   ### create structural metadata file
#
#   # write structural metadata table
#   str_metadata <- airtabler::fetch_all(base,table_name_metadata)
#   smf_file_path  <- sprintf("%s/%s.csv",output_dir_path,snakecase::to_snake_case(table_name_metadata))
#   # names(str_metadata)  <- snakecase::to_lower_camel_case(names(str_metadata))
#   utils::write.csv(str_metadata,smf_file_path,row.names = FALSE)
#
#   base_table_names <- unique(str_metadata$`Table Name`)
#   base_table_names_formatted <-  snakecase::to_snake_case(base_table_names)
#   purrr::map2(base_table_names,base_table_names_formatted, function(x,y){
#     #browser()
#     ## get fields from str_metadata
#
#      fields_exp <- str_metadata[str_metadata$`Table Name` == x,"Field Name"]
#
#     ## pull table - add check for blank tables
#     x_table <- airtabler::fetch_all(base,x)
#
#     if(!is.data.frame(x_table)){
#       x_table <- data.frame(id = character())
#     }
#
#     ## add in missing columns
#      fields_obs <- names(x_table)
#      # drop autogenerated cols from comparison
#      fields_obs  <- fields_obs[!grepl(pattern = "^id$|^createdTime$",
#                                       x = fields_obs)]
#      # check if any discrepancy between metadata and table
#      fields_diff <- set_diff(fields_exp,fields_obs)
#
#      if(!is.null(fields_diff)){
#       # check for fields in obs not in exp - error
#       obs_exp  <- setdiff(fields_obs,fields_exp)
#       if(length(obs_exp) != 0){
#         stop(glue::glue("Table {x} contains field(s) {obs_exp} not found in {table_name_metadata}. Update metadata table."))
#       }
#       # check for fields in exp and not in obs - append unless frictionless
#       if(!to_frictionless_data){
#         exp_obs <- setdiff(fields_exp,fields_obs)
#         x_table[exp_obs] <- list(character(0))
#       }
#      }
#
#      ## clean up field names
#
#     names(x_table)  <- snakecase::to_snake_case(names(x_table))
#
#     # convert list type fields to strings
#
#     x_table_flat <- dplyr::mutate(.data = x_table,
#                   dplyr::across(tidyselect:::where(is.list), purrr::flatten_chr))
#
#     ## export to CSV
#
#      output_file_path  <- sprintf("%s/%s.csv",output_dir_path,y)
#
#      utils::write.csv(x_table_flat,output_file_path,row.names = FALSE)
#   })
#
#   ## copy files from temp to final
#
#   output_dir_path_final <- sprintf("%s/%s",output_dir,output_id)
#   dir.create(output_dir_path_final,recursive = T)
#
#   outputs_list <- list.files(output_dir_path,full.names = T)
#
#   file.copy(from = outputs_list,to = output_dir_path_final,recursive = FALSE ,copy.mode = TRUE)
#
#   message(glue::glue("Files can be found here: {output_dir_path_final}"))
#
#   return(list.files(output_dir_path_final,full.names = T))
#
# }

#' Get items that differ between x and y
#'
#' Unlike setdiff, this function creates the union of x and y then
#' removes values that are in the intersect, providing values
#' that are unique to X and values that are unique to Y.
#'
#' @param x a set of values.
#' @param y a set of values.
#'
#' @return Unique values from X and Y, NULL if no unique values.
#' @export
#'
#' @examples
#' a <- 1:3
#' b <- 2:4
#'
#' set_diff(a,b)
#' # returns 1,4
#'
#' x <- 1:3
#' y <- 1:3
#'
#' set_diff(x,y)
#' # returns NULL
#'
set_diff <- function(x,y){
  u <- union(x,y)
  i <- intersect(x,y)
  j <- (u %in% i)

  if(all(j)){
    return(NULL)
  }

  diff <- u[!(j)]
  return(diff)
}

### get_metadata - returns a data frame

air_get_metadata_from_table <- function(base, table_name){
  # get structural metadata table
  str_metadata <- airtabler::fetch_all(base,table_name)
  ## check for table_name, field_name
  names(str_metadata) <- snakecase::to_snake_case(names(str_metadata))

  required_fields <- c("table_name","field_name")
  if(!all(required_fields %in% names(str_metadata))){
    stop(glue::glue("metadata table must contain the
                    following fields: {required_fields}. Note
                    that field names are converted to snakecase
                    before check."))
  }

  return(str_metadata)
}

### generate metadata - returns a data frame
air_generate_metadata <- function(base, table_names,limit=1){
  warning('Airtable does not return fields with empty values - "", false, or [].
          It is better to create a specific metdata table and
          parse that with air_get_metadata_*')
  meta_data_table <- purrr::map_dfr(table_names,function(x){
    table_x <- airtabler::air_get(base,x,limit = limit )
    fields_x <- names(table_x)

    ## guess record types?

    md_df <- data.frame(table_name = x, field_name = fields_x, field_desc = "", field_type = "")

    return(md_df)
  })

  return(meta_data_table)
}

air_get_base_description_from_table<- function(base, table_name){
  #fetch table
  desc_table <- airtabler::fetch_all(base,table_name)
  # to snake case
  names(desc_table) <- snakecase::to_snake_case(names(desc_table))

  required_fields <- c("title","primary_contact","email","base_description")
  if(all(required_fields %in% names(desc_table))){
    return(desc_table)
  } else {

    missing_rf <- required_fields[!required_fields %in% names(desc_table)]

    desc_table[missing_rf] <- NA
    return(desc_table)
  }

}

air_generate_base_description <- function(title = NA,primary_contact= NA,email = NA, base_description = NA,...){
  desc_table <- data.frame(title,primary_contact,email,base_description,...)
  return(desc_table)
}

### extract_base - returns a named list

air_dump <- function(base, metadata, description = NULL, add_missing_fields = TRUE){

  names(metadata) <- snakecase::to_snake_case(names(metadata))
  ## check for required fields
  required_fields <- c("table_name","field_name")

  if(!all(required_fields %in% names(metadata))){
    stop(glue::glue("metadata table must contain the
                    following fields: {required_fields}. Note
                    that field names are converted to snakecase
                    before check."))
  }


  base_table_names <- unique(metadata$table_name)

  table_list <- base_table_names |>
    purrr::set_names() |>
    purrr::map(function(x){
      #browser()
      ## get fields from str_metadata

      fields_exp <- metadata[metadata$table_name == x,"field_name"]

      ## pull table - add check for blank tables
      x_table <- airtabler::fetch_all(base,x)

      if(!is.data.frame(x_table)){
        x_table <- data.frame(id = character())
      }

      ## add in missing columns if any
      fields_obs <- names(x_table)

      # check if any discrepancy between metadata and table
      fields_diff <- set_diff(fields_exp,fields_obs)

      if(!is.null(fields_diff)){
        # check for fields in obs not in exp - error
        obs_exp  <- setdiff(fields_obs,fields_exp)
        if(length(obs_exp) != 0 & !all(obs_exp %in% c("id","createdTime"))){
          stop(glue::glue("Table {x} contains field(s) {obs_exp} not found in {table_name_metadata}. Update metadata table."))
        }
        # check for fields in exp and not in obs - append unless frictionless
        if(add_missing_fields){
          exp_obs <- setdiff(fields_exp,fields_obs)
          x_table[exp_obs] <- list(character(0))
        }
      }

      return(x_table)

    })

  table_list$metadata <- metadata

  if(!is.null(description)){
    table_list$description <- description
  } else {
    ## give null description
    table_list$description <- air_generate_base_description()
  }

  table_list$description$date_created <- Sys.Date()

  return(table_list)
}


### write to X

air_dump_to_csv <- function(table_list,output_dir= "outputs", overwrite = FALSE){

  output_id <- rlang::hash(table_list)
  output_dir_path <- sprintf("%s/%s",output_dir,output_id)
  # check if data already exist

  if(dir.exists(output_dir_path) & !overwrite){
    message("data already exist, files not written")
    return(list.files(output_dir_path))
  }

  dir.create(output_dir_path,recursive = TRUE)

  purrr::walk2(table_list, names(table_list), function(x_table,y_table_name){
    ##  clean table name
    y_table_name <- snakecase::to_snake_case(y_table_name)
    ## clean up field names in table
    names(x_table)  <- snakecase::to_snake_case(names(x_table))


    ## clean up field names
    names(x_table)  <- snakecase::to_snake_case(names(x_table))
  if(y_table_name == "table_2"){
    browser()
  }

    purrr::map_dfc(x_table, function(x){
      if(is.list(x)){
        x <- purrr::flatten_dfc(x)
      }
      return(x)
    })

    # convert list type fields to strings
    x_table_flat <- dplyr::mutate(.data = x_table,
                                  dplyr::across(
                                    tidyselect:::where(is.list),
                                    unlist)
                                  )

    ## export to CSV

    output_file_path  <- sprintf("%s/%s.csv",output_dir_path,y_table_name)

    utils::write.csv(x_table_flat,output_file_path,row.names = FALSE)
  })
}



### recover from metadata - JS code to regenerate tables
